<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8" />
	<title>Shark Life :)</title>
	<style>* { padding: 0; margin: 0; }</style>
	<script src="js/phaser.min.js"></script>
</head>
<body>
<script>

	let typeFishs = [
		{name: 'shark', img: 'img/shark.png', lvl: 1, width: 60, height: 20},
		{name: 'fish-lvl-1', img: 'img/1.png', lvl: 1, width: 45, height: 15, pointsByKill: 1, speed: 150},
		{name: 'fish-lvl-2', img: 'img/2.png', lvl: 2, width: 75, height: 25, pointsByKill: 2, speed: 170},
		{name: 'fish-lvl-3', img: 'img/3.png', lvl: 3, width: 105, height: 35, pointsByKill: 3, speed: 180},
		{name: 'fish-lvl-4', img: 'img/4.png', lvl: 4, width: 120, height: 40, pointsByKill: 4, speed: 200},
		{name: 'fish-lvl-5', img: 'img/5.png', lvl: 5, width: 150, height: 50, pointsByKill: 5, speed: 220},
		{name: 'fish-lvl-6', img: 'img/6.png', lvl: 6, width: 175, height: 65, pointsByKill: 6, speed: 230},
		{name: 'killer-1', img: 'img/killer1.png', lvl: 9999, width: 80, height: 80, pointsByKill: 100, speed: 70},
		{name: 'killer-5', img: 'img/killer2.png', lvl: 9999, width: 150, height: 50, pointsByKill: 100, speed: 450}
	];
	let typeKillers = [

	];
	let live, killersTime1, killersTime2;
	let scoreText;
	let score = 0
	let scoreForNextLvl = 10;
	let lvl = 1;
	let timer;

	let pad, stick;
	let fishs, killers, shark;
	let sea, floor;
	let game = new Phaser.Game({
		renderer: Phaser.CANVAS,
		width: 800,
		height: 600,
		state: {
			preload: preload,
			create: create,
			update: update
		}
	});

	function preload() {
		game.scale.scaleMode = Phaser.ScaleManager.SHOW_ALL;
		game.scale.pageAlignHorizontally = true;
		game.scale.pageAlignVertically = true;
		game.stage.backgroundColor = '#3ba0ee';

		game.load.image('sea', 'img/sea.png');
		game.load.image('floor', 'img/floor.png');
		game.load.image('shark', 'img/shark.png');
		//this.game.load.image("6", "img/6.png");
		game.load.physics('sprite-physics', 'https://andreyspoki4.github.io//img/sprite-physics.json');
		// for(let fish of typeFishs)
		// 	game.load.image(fish.name, fish.img);



	}
	function create() {
		this.game.state.start("Main");
		game.physics.startSystem(Phaser.Physics.P2JS);
		createMap();
		createShark();
		//movingSharkDirection();
		qq = game.cache.getPhysicsData('sprite-physics');

	}
	function update() {
		//game.physics.arcade.collision(shark, timer);
		// game.physics.arcade.collide(shark, fishs.children, eat);
	}
	function eat(shark, fish) {
		let fishInfo = typeFishs[fish.numFish];
		if(typeFishs[0].lvl >= fishInfo.lvl){
			score += fishInfo.pointsByKill;
			scoreForNextLvl -= fishInfo.pointsByKill;
			fish.destroy();
			if(scoreForNextLvl <= 0 ){
				typeFishs[0].lvl += 1;
				scoreForNextLvl = 10 * typeFishs[0].lvl;
				shark.width += parseInt(shark.width / 3);
				shark.height += parseInt(shark.height / 3);
			}
		}
		else{
			clearInterval(live);
			shark.inputEnabled = false;
			fishs.forEach(removeFishs);
			shark.destroy();
			alert("Game Over! You score: " + score)
			score = 0;
			createShark();
			movingSharkDirection();
			createFishs();


		}

		scoreText.setText('Score: '+score);
	}
	function removeFishs(fish) {
		fish.kill();
	}
	function createFishs() {
		//timer = new Phaser.Timer
		fishs = game.add.group();
		game.physics.enable(fishs, Phaser.Physics.ARCADE, false);
		live = setInterval(function(){
			let maxY = game.world.height - floor.height - (shark.height / 2);
			let minY = (shark.height / 2);
			let y = Math.random() * (maxY - minY) + minY;

			let outWorldDistance = 150;
			let direction = Math.random() > 0.5 ? -1 : 1;
			let x = direction > 0 ? (-1 * outWorldDistance) : (outWorldDistance + game.world.width);

			let randomFishIndex = parseInt(Math.random() * (typeFishs.length - 1) + 1);
			let randomFish = typeFishs[randomFishIndex];


			let fish = game.add.sprite(x, y, randomFish.name);
			fish.numFish = randomFishIndex;
			fish.width = randomFish.width;
			fish.height = randomFish.height;
			if(direction < 0)
				fish.scale.x *= -1;
			game.physics.enable(fish, Phaser.Physics.ARCADE, false);
			fish.body.velocity.set(direction * randomFish.speed, 0);
			fish.checkWorldBounds = true;

			fishs.addChild(fish);

			fish.events.onOutOfBounds.add(function(fish){
				if(
					((direction > 0) && (fish.x > 0))
					||
					((direction < 0) && (fish.x < 0))
				)
					fish.destroy();
			}, this);

		}, 500);

	}
	// function createKillers() {
	// 	let createKiller1 = bindKiller[typeKillers[0]];
	// 	let createKiller2 = bindKiller[typeKillers[1]];
	// 	killers = game.add.group();
	// 	game.physics.enable(killers, Phaser.Physics.ARCADE, false);
	// 	killersTime1 = setInterval(createKiller1, 2500);
	// 	killersTime2 = setInterval(createKiller2, 5000);
	// }
	// function bindKiller(killer) {
	// 	return function () {
	// 		let maxY = game.world.height - floor.height - (shark.height / 2);
	// 		let minY = (shark.height / 2);
	// 		let y = Math.random() * (maxY - minY) + minY;
	//
	// 		let outWorldDistance = 150;
	// 		let direction = Math.random() > 0.5 ? -1 : 1;
	// 		let x = direction > 0 ? (-1 * outWorldDistance) : (outWorldDistance + game.world.width);
	//
	// 		let killer = game.add.sprite(x, y, killer.name);
	// 		killer.width = killer.width;
	// 		killer.height = killer.height;
	// 		if (direction < 0)
	// 			killer.scale.x *= -1;
	// 		game.physics.enable(killer, Phaser.Physics.ARCADE, false);
	// 		killer.body.velocity.set(direction * killer.speed, 0);
	// 		killer.checkWorldBounds = true;
	//
	// 		killers.addChild(killer);
	//
	// 		killer.events.onOutOfBounds.add(function (killer) {
	// 			if (
	// 					((direction > 0) && (killer.x > 0))
	// 					||
	// 					((direction < 0) && (killer.x < 0))
	// 			)
	// 				killer.destroy();
	// 		}, this);
	// 	}
	// }
	function createShark(){
		shark = game.add.sprite(0, 0, 'shark');
		// shark.width = typeFishs[0].width;
		// shark.height = typeFishs[0].height;
		shark.x = (game.world.width - shark.width) / 2;
		shark.y = game.world.height - floor.height - (shark.height / 2);
		shark.anchor.set(0.5, 0.5);
		shark.inputEnabled = true;
		shark.input.enableDrag(true);
		shark.input.boundsRect = new Phaser.Rectangle(0, 0, game.world.width, game.world.height - floor.height);

		game.physics.p2.enable(shark, true);
		shark.body.clearShapes();
		shark.body.loadPolygon('sprite-physics', 'shark');
		shark.body.static = true;

		game.physics.p2.moveToPointer(shark, 400);
	}
	function createMap(){
		sea = game.add.sprite(0, 0, 'sea');
		floor = game.add.sprite(0, 0, 'floor');
		floor.y = game.world.height - floor.height;
		game.physics.p2.enable(floor);
		floor.body.static = true;
		floor.anchor.setTo(0, 0);
	}

	function movingSharkDirection(){
		let startX = shark.x;
		shark.events.onDragUpdate.add((shark, pointer, newX) => {
			if(newX < Math.abs(shark.width / 2))
				shark.x = Math.abs(shark.width / 2);
			if(newX < startX)
				shark.scale.x = -1 * Math.abs(shark.scale.x);
			if(newX > startX)
				shark.scale.x = Math.abs(shark.scale.x);
			startX = newX;
		}, this);
	}

	layer.update = function () {
		player.body.velocity.x = 0; //default speed - stationary
	    if ( game.input.keyboard.isDown( controls.left ) ) {
	    player.scale.x = -1;
	    player.body.moveLeft( sideSpeed );
	    player.body.clearShapes();
	    player.body.loadPolygon('physicsLeftData', 'player');
	    setBody();
	    }
	    else if ( game.input.keyboard.isDown( controls.right ) ) {
	    player.scale.x = 1;
	    player.body.clearShapes();
	    player.body.loadPolygon('physicsData', 'player');
	    console.log( player.body );
	    player.body.moveRight( sideSpeed );
	    setBody()
	    }
	    if ( game.input.keyboard.isDown( controls.jump ) && checkIfCanJump() && this.game.time.now > player.jumpTimer ) {
	    player.body.moveUp( jumpSpeed ) ;
	    player.jumpTimer = this.game.time.now + 0;
	    }
	    };function setBody() {
	    player.body.fixedRotation = true;
	    player.body.setCollisionGroup( collisionGroup );
	    player.body.setMaterial( material );
	    player.body.collideWorldBounds = true;
	    player.body.mass = 4; }
</script>
</body>
</html>